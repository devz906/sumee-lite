import SwiftUI
import Combine

// HomeViewModel+Layout.swift

extension HomeViewModel {
    
    // Layout & Grid Management
    
    // Flatten all items and re-distribute into pages of 10 (VitaGridHelper.itemsPerPage)
    func consolidatePages() {
        // 1. Flatten pages & remove ONLY STRUCTURAL spacers (generated by widgets)
        // We MUST preserve "Empty" items (Manual Drops)
        let allItems = pages.flatMap { $0 }.filter { item in
            if item.name == "Empty" { return false }
            if item.name == "News Widget" { return false } // Explicitly Remove News Widget
            if item.isSpacer { return false } // Remove structural spacers (tails)
            return true // Keep Apps/Widgets
        }
        
        guard !allItems.isEmpty else { return }
        
        // 2. Reflow using Grid Logic
        let newPages = reflowLayoutGrid(allItems)
        
        // Check structural changes (content or count)
        pages = newPages
        saveLayout()
    }
    
    // Helper for chunking (replaces simple chunked)
    func reflowLayoutGrid(_ rawItems: [AppItem]) -> [[AppItem]] {
        var newPages: [[AppItem]] = []
        var remainingItems = rawItems
        let pageSize = VitaGridHelper.itemsPerPage // 10
        
        while !remainingItems.isEmpty {
            // Take up to pageSize items
            let count = min(remainingItems.count, pageSize)
            var page = Array(remainingItems[0..<count])
            remainingItems.removeFirst(count)
            
            // Spacers removed (can be usefull later)
            // while page.count < pageSize { ... }
            
            newPages.append(page)
            
            // Safety break
            if newPages.count > 20 { break } 
        }
        
        // Ensure at least one page if empty
        if newPages.isEmpty {
            var page: [AppItem] = []
            // Spacers removed
            // for _ in 0..<pageSize { ... }
            newPages.append(page)
        }
        
        // Print page breakdown
        print("Reflow resulted in \(newPages.count) pages.")
        
        return newPages
    }
    
    // Explicitly clean up trailing empty pages from the main list
    func cleanupTrailingEmptyPages() {
        print(" Cleaning up empty pages...")
        var index = 0
        while index < pages.count {
            // Keep first page always
            if index == 0 {
                index += 1
                continue
            }
            
            let page = pages[index]
            // Definition of "Empty Page" in Fixed Grid:
            // All items are either Structural Spacers OR Manual "Empty" Drops.
            // If there is ANY Real App or Widget, keep the page.
            let isEmpty = page.allSatisfy { item in
                return item.isSpacer || item.name == "Empty"
            }
            
            if isEmpty {
                print("Removing Page \(index) (Generic Spacers/Drops only)")
                pages.remove(at: index)
                // Do not increment index, as next page shifts down
            } else {
                index += 1
            }
        }
        
        // Ensure index is valid
        if selectedTabIndex >= pages.count {
            selectedTabIndex = max(0, pages.count - 1)
        }
    }
    
    // Drag & Drop Logic
    func moveApp(source: AppItem, destination: AppItem) {
        // Simple Swap Logic for fixed grid stability
 
        
        guard let sourcePageIdx = pages.firstIndex(where: { $0.contains { $0.id == source.id } }),
              let sourceItemIdx = pages[sourcePageIdx].firstIndex(where: { $0.id == source.id }) else { return }
              
        guard let destPageIdx = pages.firstIndex(where: { $0.contains { $0.id == destination.id } }),
              let destItemIdx = pages[destPageIdx].firstIndex(where: { $0.id == destination.id }) else { return }
              
        // Perform Swap
        withAnimation(.spring(response: 0.4, dampingFraction: 0.7)) {
            if sourcePageIdx == destPageIdx {
                pages[sourcePageIdx].swapAt(sourceItemIdx, destItemIdx)
            } else {
                let temp = pages[destPageIdx][destItemIdx]
                pages[destPageIdx][destItemIdx] = pages[sourcePageIdx][sourceItemIdx]
                pages[sourcePageIdx][sourceItemIdx] = temp
            }
        }
        
        saveLayout()
    }

    // Helper for chunking
    func chunked(_ apps: [AppItem], size: Int) -> [[AppItem]] {
        return stride(from: 0, to: apps.count, by: size).map {
            Array(apps[$0..<min($0 + size, apps.count)])
        }
    }
    
    // Migration helper to put widgets into grid
    func ensureWidgetsInPages() {
        // Disabled for Vita Grid Re-implementation
     
    }
    
    func addAppToFirstAvailableSlot(_ app: AppItem) {
        //  GRID LOGIC:
  
        
        for i in 0..<pages.count {
            if let emptyIndex = pages[i].firstIndex(where: { $0.name == "Empty" }) {
                // Found an empty slot! Replace it.
                pages[i][emptyIndex] = app
                return
            }
            
       
            if pages[i].count < VitaGridHelper.itemsPerPage {
                pages[i].append(app)
                return
            }
        }
        

        pages.append([app])
    }
    
    // Internal helper for ensureWidgetsInPages
    private func insertItemWithCascade(_ item: AppItem, pageIndex: Int, at index: Int) {
         // Insert item
         if pageIndex < pages.count {
             var page = pages[pageIndex]
             let safeIndex = min(index, page.count)
             page.insert(item, at: safeIndex)
             pages[pageIndex] = page
         } else {
             pages.append([item])
         }
    }
    
    // NOTE: This was moved from Navigation because it deals with Layout
    // Widget resizing logic removed as per user request to delete widgets
    
    // updateWidgetSize removed
    
    func handleWidgetAction() {
        // Deprecated or simplified
        guard gameController.isSelectingWidget else { return }
        // Logic removed as widgets are now normal apps
    }
}
